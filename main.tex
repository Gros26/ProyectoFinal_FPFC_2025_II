\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\title{Proyecto}
\author{Sebastian Ovi}
\date{November 2025}

\begin{document}

\maketitle

\section*{Correctitud de la función \texttt{itinerariosTiempo}}

Sea \texttt{itinerariosTiempo(vuelos,aeropuertos)} una función que retorna otra
función $G$ tal que, dados dos códigos de aeropuerto $c_1$ y $c_2$,
$G(c_1,c_2)$ devuelve la lista de itinerarios mínimos en tiempo total
de viaje entre dichos aeropuertos. Internamente, la función utiliza un
procedimiento recursivo \texttt{buscarTiempo} que explora todas las
rutas posibles, descarta aquellas con ciclos y finalmente selecciona
las de menor tiempo total.

Para demostrar la correctitud de esta implementación, consideremos la
siguiente especificación matemática del problema:

\begin{itemize}
    \item Sea $V$ el conjunto de todos los vuelos disponibles.
    \item Un itinerario desde $c_1$ hasta $c_2$ es una secuencia de vuelos
          $\langle v_1,\dots,v_m \rangle$ tal que:
          \begin{enumerate}
              \item $v_1.\mathrm{Org} = c_1$,
              \item $v_m.\mathrm{Dst} = c_2$,
              \item $v_i.\mathrm{Dst} = v_{i+1}.\mathrm{Org}$ para todo $i$,
              \item No existen ciclos: ningún aeropuerto aparece dos veces.
          \end{enumerate}
    \item El tiempo total del itinerario es la suma de las duraciones de cada vuelo.
    \item La función debe devolver exactamente los tres itinerarios de menor tiempo total,
          o menos si existen menos rutas posibles.
\end{itemize}

Denotemos por $F(c)$ el conjunto de todos los itinerarios válidos desde un
aeropuerto $c$ hasta el destino $d$ (fijo para cada llamada).
Sea \texttt{buscarTiempo(actual, destino, visitados)} la implementación recursiva.
Queremos demostrar que la función computa exactamente $F(c)$.

\subsection*{Definición de Correctitud}

Diremos que la implementación es correcta si, para todo aeropuerto
$A$ y destino $D$:

\[
\texttt{buscarTiempo}(A, D, \{A\}) = F(A)
\]

y la función \texttt{itinerariosTiempo} selecciona efectivamente los
itinerarios de mínimo tiempo.

\subsection*{Demostración por inducción estructural}

La función es naturalmente recursiva sobre la estructura del grafo
dirigido de vuelos, por lo que utilizamos inducción sobre la \emph{longitud}
de los itinerarios posibles desde un aeropuerto dado.

Sea $T(a)$ el conjunto de itinerarios válidos desde el aeropuerto $a$
hasta el destino $d$. Demostraremos que:

\[
\texttt{buscarTiempo}(a,d,visitados) = T(a)
\]

para todo aeropuerto $a$ y conjunto de visitados con $a \in visitados$.

\subsubsection*{Caso base}

Si $a = d$, la especificación indica que existe exactamente un itinerario:
la secuencia vacía que representa ``no hay más vuelos que tomar''.

La implementación retorna:

\[
\texttt{List(Nil)}
\]

lo cual coincide con la especificación:

\[
T(d) = \{\langle \;\rangle\}.
\]

Por tanto, el caso base es correcto.

\subsubsection*{Paso inductivo}

Supongamos que para todos los aeropuertos $x$ tales que toda ruta
posible desde $x$ al destino tiene longitud estrictamente menor que
las rutas desde $a$, la implementación satisface:

\[
\texttt{buscarTiempo}(x, d, visitados \cup \{x\}) = T(x).
\]

Demostremos la correctitud para $a \neq d$.

La implementación construye el conjunto:

\[
V(a) = \{ v \in V \mid v.\mathrm{Org} = a \;\wedge\; v.\mathrm{Dst} \notin visitados \}.
\]

Es decir, todos los vuelos posibles desde $a$ sin entrar en ciclo.  
Esto coincide exactamente con la definición matemática del conjunto de vuelos válidos.

Para cada vuelo $v \in V(a)$, la implementación calcula recursivamente:

\[
\texttt{buscarTiempo}(v.\mathrm{Dst}, d, visitados \cup \{v.\mathrm{Dst}\}).
\]

Por hipótesis inductiva, esto retorna exactamente el conjunto de todos
los itinerarios desde $v.\mathrm{Dst}$ hasta $d$.

La implementación construye entonces todos los itinerarios desde $a$ como:

\[
\bigcup_{v \in V(a)} \{v\} \mathbin{::} T(v.\mathrm{Dst}),
\]

que coincide \emph{exactamente} con la definición matemática de $T(a)$.

Dado que:

\begin{itemize}
    \item no se omite ningún vuelo posible,
    \item no se incluyen vuelos que generen ciclos,
    \item todas las rutas se generan mediante concatenación correcta,
\end{itemize}

queda demostrado que:

\[
\texttt{buscarTiempo}(a,d,visitados) = T(a).
\]

\subsection*{Mínimo tiempo total}

Una vez generado $T(c_1)$, la función \texttt{itinerariosTiempo}:

\begin{enumerate}
    \item Calcula la duración total de cada itinerario.
    \item Ordena los itinerarios por su tiempo total.
    \item Toma los tres primeros mediante \texttt{take(3)}.
\end{enumerate}

Esto corresponde exactamente a seleccionar:

\[
\text{los 3 elementos mínimos del conjunto } T(c_1)
\]

bajo el orden total definido por el tiempo total de viaje.

Dado que la función genera el conjunto completo de itinerarios válidos
y luego selecciona los de tiempo mínimo, concluimos que la implementación
es correcta.

\subsection*{Conclusión}

Por inducción sobre la profundidad de búsqueda en el grafo y por análisis
funcional de la minimización, queda demostrado que:

\[
\texttt{itinerariosTiempo(vuelos,aeropuertos)(c_1,c_2)}
\]

\emph{devuelve exactamente los tres itinerarios de menor tiempo total de viaje},
cumpliendo con la especificación formal del problema.


\section*{Correctitud de la función \texttt{itinerariosTiempoPar} por inducción}

Sea $G(c_1,c_2)$ la función que devuelve todos los itinerarios posibles entre los aeropuertos
$c_1$ y $c_2$, generados por la versión paralela \texttt{itinerariosPar}.
Sea además $T(it)$ la función que calcula el tiempo total del itinerario $it$.

La función \texttt{itinerariosTiempoPar} se define como:
\[
\texttt{itinerariosTiempoPar}(c_1,c_2)
  = \text{los tres itinerarios en } G(c_1,c_2) \text{ con menor tiempo total}.
\]

Formalmente, sea:
\[
G(c_1,c_2) = \{ it_1, it_2, \dots, it_m \}.
\]

Sea también la relación de orden:
\[
it_a \prec it_b \iff T(it_a) < T(it_b).
\]

La función paralela implementa:
\[
\texttt{ordenados} =
\text{sort}\Big( \{ (T(it), it) \mid it \in G(c_1,c_2) \} \Big),
\]
y retorna:
\[
\texttt{ordenados.take}(3).
\]

Queremos demostrar que la implementación devuelve \emph{exactamente}
los tres itinerarios con mínimo tiempo total entre los generados por \texttt{itinerariosPar}.
Esto se prueba por inducción estructural sobre la longitud $m = |G(c_1,c_2)|$.

\subsection*{Caso base: $m = 0$}

Si $G(c_1,c_2)=\emptyset$, no existe ruta entre $c_1$ y $c_2$.
La implementación evalúa:

\[
\{ (T(it),it) \mid it\in \emptyset \} = \emptyset.
\]

Ordenar un conjunto vacío produce un conjunto vacío:
\[
\texttt{sort}(\emptyset) = \emptyset.
\]

Finalmente,
\[
\texttt{take}(3) = \emptyset.
\]

Como no existen itinerarios, la salida es correcta.
Por tanto,
\[
\texttt{itinerariosTiempoPar}(c_1,c_2) = \emptyset,
\quad \text{que coincide con la especificación.}
\]

\subsection*{Paso inductivo}

Supongamos que la función es correcta para todos los conjuntos de itinerarios
de tamaño $m$, es decir:

\[
|G(c_1,c_2)| = m \quad \Rightarrow \quad
\texttt{itinerariosTiempoPar}(c_1,c_2)
\text{ devuelve los tres itinerarios de menor tiempo}.
\]

\medskip

Demostremos que esto implica la correctitud para un conjunto de tamaño $m+1$.

Sea:

\[
G = \{ it_1, it_2, \dots, it_m, it_{m+1} \}.
\]

Entonces la implementación evalúa el conjunto:

\[
S = \{ (T(it_1),it_1),\dots,(T(it_m),it_m),(T(it_{m+1}),it_{m+1})\}.
\]

Por hipótesis inductiva, el subtérmino:
\[
S' = \{ (T(it),it) \mid it\in G\setminus\{it_{m+1}\} \}
\]
se ordena correctamente y su \texttt{take(3)} contiene
los tres itinerarios más rápidos en $G \setminus \{it_{m+1}\}$.

Ahora consideremos $it_{m+1}$.

Existen únicamente dos casos posibles:

\begin{enumerate}
  \item $T(it_{m+1})$ es mayor que los tres mínimos ya presentes en $S'$.
        Entonces la ordenación completa:
        \[
          \texttt{sort}(S' \cup \{(T(it_{m+1}),it_{m+1})\})
        \]
        preserva los tres mínimos de $S'$.

  \item $T(it_{m+1})$ es menor que al menos uno de los tres mínimos.
        En ese caso, después de ordenar:
        \[
          \texttt{sort}(S' \cup \{(T(it_{m+1}),it_{m+1})\}),
        \]
        el algoritmo lo insertará en la posición correspondiente,
        desplazando el itinerario de mayor tiempo entre los anteriores tres mínimos.
\end{enumerate}

En ambos casos, la operación
\[
\texttt{take}(3)
\]
extrae exactamente los tres itinerarios con menor $T(it)$ en $G$.

Por tanto,
\[
\texttt{itinerariosTiempoPar}(c_1,c_2)
\]
es correcta para conjuntos de tamaño $m+1$.

\subsection*{Conclusión}

Por inducción, para todo $m\ge 0$:

\[
\texttt{itinerariosTiempoPar}(c_1,c_2)
= \text{los tres itinerarios con menor tiempo total en } G(c_1,c_2).
\]

La implementación es correcta.





\end{document}
